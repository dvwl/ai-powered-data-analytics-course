---
lab:
    title: 'SQL Fundamentals for Data Analysts'
---
# Module 2: SQL Fundamentals for Data Analysts

## Datasets

**Sources:** 
- [`ice-cream-weather-dataset.csv`](../data/ice-cream-weather-dataset.csv) - Daily sales data
- [`employee-dataset.csv`](../data/employee-dataset.csv) - Employee information
- [`customer-transactions-dataset.csv`](../data/customer-transactions-dataset.csv) - Individual transactions

> Disclaimer: Data is generated by AI for educational purposes.

For this module, we'll work with three related datasets imported into a SQL database:

### `ice_cream_sales` Table (Daily aggregated data)
- **date**: Date of sales (DATE format)
- **location**: Sales location (Downtown, Beach Park, Mall Central)
- **temperature_f**: Daily temperature in Fahrenheit (DECIMAL)
- **price**: Average price per ice cream unit in dollars (DECIMAL)
- **tourists_thousands**: Tourist count in thousands (DECIMAL)
- **sales_thousands**: Ice cream sales in thousands of dollars (DECIMAL)
- **is_rainy**: Weather condition (BOOLEAN - TRUE for rainy, FALSE for dry)

### `employees` Table
- **employee_id**: Unique employee identifier (INTEGER, PRIMARY KEY)
- **first_name, last_name**: Employee names (VARCHAR)
- **location**: Work location (VARCHAR) - Links to ice_cream_sales
- **hire_date**: Employee start date (DATE)
- **position**: Job title (VARCHAR)
- **hourly_wage**: Hourly pay rate (DECIMAL)
- **department**: Department (Operations/Sales) (VARCHAR)
- **manager_id**: Manager's employee_id (INTEGER, FOREIGN KEY)
- **performance_rating**: Performance evaluation (VARCHAR)
- **total_hours_worked**: Cumulative hours (INTEGER)

### `customer_transactions` Table
- **id**: Unique identifier (INTEGER)
- **date**: Transaction date (DATE)
- **location**: Store location (VARCHAR)
- **employee_id**: Serving employee (INTEGER, FOREIGN KEY)
- **transaction_time**: Time of purchase (TIME)
- **items_purchased**: Number of items (INTEGER)
- **total_spent**: Transaction amount (DECIMAL)
- **customer_age_group**: Age category (VARCHAR)
- **payment_method**: Payment type (VARCHAR)
- **satisfaction_rating**: Customer rating 1-5 (INTEGER)
- **return_customer**: Repeat customer flag (BOOLEAN)
- **promotional_code_used**: Promo code applied (VARCHAR)
- **weather_sensitive**: Customer affected by weather (BOOLEAN)

---

## Lab 1: Setting Up Practice Database and Basic Queries

### Objective

Connect to the database, explore the data structure, and perform basic SELECT operations.

### Steps

1. **Connect to Database**:
   ```sql
   -- Connect to your SQL environment (SQLite, MySQL, PostgreSQL, etc.)
   -- Load the ice_cream_sales table from the CSV data
   ```

2. **Explore Data Structure**:
   ```sql
   -- View table structure
   DESCRIBE ice_cream_sales;
   
   -- Or for some databases:
   PRAGMA table_info(ice_cream_sales);
   ```

3. **Basic Data Exploration**:
   ```sql
   -- View first 10 rows
   SELECT * FROM ice_cream_sales LIMIT 10;
   
   -- Count total records
   SELECT COUNT(*) as total_records FROM ice_cream_sales;
   
   -- View unique locations
   SELECT DISTINCT location FROM ice_cream_sales;
   ```

4. **Basic Filtering**:
   ```sql
   -- Sales on hot days (temperature > 85°F)
   SELECT date, location, temperature_f, sales_thousands
   FROM ice_cream_sales
   WHERE temperature_f > 85
   ORDER BY sales_thousands DESC;
   
   -- Rainy day sales
   SELECT date, location, sales_thousands, temperature_f
   FROM ice_cream_sales
   WHERE is_rainy = TRUE
   ORDER BY date;
   ```

5. **Data Range Analysis**:
   ```sql
   -- Date range in dataset
   SELECT 
       MIN(date) as start_date,
       MAX(date) as end_date,
       COUNT(DISTINCT date) as total_days
   FROM ice_cream_sales;
   
   -- Temperature range
   SELECT 
       MIN(temperature_f) as min_temp,
       MAX(temperature_f) as max_temp,
       AVG(temperature_f) as avg_temp
   FROM ice_cream_sales;
   ```

---

## Lab 2: Working with Multiple Tables - Employee Database Analysis

### Objective

Analyze employee data and explore relationships between employees, locations, and sales performance using JOIN operations.

### Steps

1. **Explore Employee Data Structure**:
   ```sql
   -- View all employees
   SELECT * FROM employees LIMIT 10;
   
   -- Count employees by location
   SELECT location, COUNT(*) as employee_count
   FROM employees
   GROUP BY location;
   
   -- View management hierarchy
   SELECT 
       e1.first_name || ' ' || e1.last_name as employee,
       e1.position,
       e2.first_name || ' ' || e2.last_name as manager
   FROM employees e1
   LEFT JOIN employees e2 ON e1.manager_id = e2.employee_id
   ORDER BY e1.location, e1.position;
   ```

2. **Employee Performance Analysis**:
   ```sql
   -- Average wages by position and location
   SELECT 
       location,
       position,
       COUNT(*) as employee_count,
       AVG(hourly_wage) as avg_wage,
       MIN(hourly_wage) as min_wage,
       MAX(hourly_wage) as max_wage
   FROM employees
   GROUP BY location, position
   ORDER BY location, avg_wage DESC;
   
   -- Performance ratings distribution
   SELECT 
       performance_rating,
       COUNT(*) as employee_count,
       AVG(hourly_wage) as avg_wage,
       AVG(total_hours_worked) as avg_hours
   FROM employees
   GROUP BY performance_rating
   ORDER BY avg_wage DESC;
   ```

3. **JOIN Analysis - Employee Location Performance**:
   ```sql
   -- Join employees with daily sales to analyze location staffing vs performance
   SELECT 
       e.location,
       COUNT(DISTINCT e.employee_id) as total_employees,
       AVG(s.sales_thousands) as avg_daily_sales,
       SUM(s.sales_thousands) as total_sales,
       AVG(e.hourly_wage) as avg_wage_cost
   FROM employees e
   INNER JOIN ice_cream_sales s ON e.location = s.location
   GROUP BY e.location
   ORDER BY avg_daily_sales DESC;
   ```

4. **Department Analysis**:
   ```sql
   -- Sales vs Operations department breakdown
   SELECT 
       e.department,
       e.location,
       COUNT(*) as dept_employees,
       AVG(e.hourly_wage) as avg_wage,
       AVG(s.sales_thousands) as avg_location_sales
   FROM employees e
   INNER JOIN ice_cream_sales s ON e.location = s.location
   GROUP BY e.department, e.location
   ORDER BY e.location, e.department;
   ```

5. **Tenure and Performance Correlation**:
   ```sql
   -- Analyze relationship between hire date and performance
   SELECT 
       CASE 
           WHEN hire_date >= '2024-01-01' THEN 'New Hire (2024)'
           WHEN hire_date >= '2023-06-01' THEN 'Recent (Jun-Dec 2023)'
           ELSE 'Experienced (Before Jun 2023)'
       END as tenure_group,
       COUNT(*) as employee_count,
       AVG(hourly_wage) as avg_wage,
       AVG(total_hours_worked) as avg_hours,
       COUNT(CASE WHEN performance_rating = 'Excellent' THEN 1 END) as excellent_performers
   FROM employees
   GROUP BY 
       CASE 
           WHEN hire_date >= '2024-01-01' THEN 'New Hire (2024)'
           WHEN hire_date >= '2023-06-01' THEN 'Recent (Jun-Dec 2023)'
           ELSE 'Experienced (Before Jun 2023)'
       END
   ORDER BY avg_wage DESC;
   ```

---

## Lab 3: Sales Analysis by Region and Product

### Objective

Use data aggregation and grouping techniques to analyze sales patterns by location, weather conditions, and time periods - recreating the Excel pivot table analysis in SQL.

### Steps

1. **Sales Performance by Location**:
   ```sql
   -- Total and average sales by location (similar to pivot table)
   SELECT 
       location,
       COUNT(*) as total_days,
       SUM(sales_thousands) as total_sales,
       AVG(sales_thousands) as avg_daily_sales,
       MIN(sales_thousands) as min_sales,
       MAX(sales_thousands) as max_sales,
       STDDEV(sales_thousands) as sales_stddev
   FROM ice_cream_sales
   GROUP BY location
   ORDER BY total_sales DESC;
   ```

2. **Weather Impact Analysis**:
   ```sql
   -- Sales comparison: Rainy vs Dry days
   SELECT 
       location,
       CASE WHEN is_rainy THEN 'Rainy' ELSE 'Dry' END as weather_condition,
       COUNT(*) as total_days,
       AVG(sales_thousands) as avg_sales,
       AVG(temperature_f) as avg_temperature,
       SUM(sales_thousands) as total_sales,
       AVG(tourists_thousands) as avg_tourists
   FROM ice_cream_sales
   GROUP BY location, is_rainy
   ORDER BY location, avg_sales DESC;
   ```

3. **Temperature Categories Analysis**:
   ```sql
   -- Create temperature categories and analyze sales (recreating Excel categories)
   SELECT 
       location,
       CASE 
           WHEN temperature_f >= 85 THEN 'Hot (85°F+)'
           WHEN temperature_f >= 70 THEN 'Warm (70-84°F)'
           ELSE 'Cool (<70°F)'
       END as temp_category,
       COUNT(*) as days_count,
       AVG(sales_thousands) as avg_sales,
       SUM(sales_thousands) as total_sales,
       AVG(tourists_thousands) as avg_tourists,
       AVG(price) as avg_price
   FROM ice_cream_sales
   GROUP BY location, 
       CASE 
           WHEN temperature_f >= 85 THEN 'Hot (85°F+)'
           WHEN temperature_f >= 70 THEN 'Warm (70-84°F)'
           ELSE 'Cool (<70°F)'
       END
   ORDER BY location, avg_sales DESC;
   ```

4. **Monthly Sales Trends**:
   ```sql
   -- Sales by month and location
   SELECT 
       strftime('%Y-%m', date) as month,
       strftime('%B', date) as month_name,
       location,
       COUNT(*) as total_days,
       SUM(sales_thousands) as total_sales,
       AVG(sales_thousands) as avg_daily_sales,
       AVG(temperature_f) as avg_temperature,
       COUNT(CASE WHEN is_rainy THEN 1 END) as rainy_days
   FROM ice_cream_sales
   GROUP BY strftime('%Y-%m', date), strftime('%B', date), location
   ORDER BY month, location;
   ```

5. **Sales Performance Categories with Cross-Analysis**:
   ```sql
   -- Categorize sales performance and analyze patterns
   SELECT 
       location,
       CASE 
           WHEN sales_thousands >= 100 THEN 'High (100k+)'
           WHEN sales_thousands >= 75 THEN 'Medium (75-99k)'
           ELSE 'Low (<75k)'
       END as performance_category,
       COUNT(*) as days_count,
       AVG(temperature_f) as avg_temperature,
       AVG(tourists_thousands) as avg_tourists,
       AVG(price) as avg_price,
       COUNT(CASE WHEN is_rainy THEN 1 END) as rainy_days,
       ROUND(100.0 * COUNT(CASE WHEN is_rainy THEN 1 END) / COUNT(*), 1) as rainy_day_percentage
   FROM ice_cream_sales
   GROUP BY location,
       CASE 
           WHEN sales_thousands >= 100 THEN 'High (100k+)'
           WHEN sales_thousands >= 75 THEN 'Medium (75-99k)'
           ELSE 'Low (<75k)'
       END
   ORDER BY location, performance_category;
   ```

6. **Advanced Aggregation with HAVING Clause**:
   ```sql
   -- Find locations and months with consistently high performance
   SELECT 
       location,
       strftime('%B', date) as month_name,
       COUNT(*) as total_days,
       AVG(sales_thousands) as avg_sales,
       MIN(sales_thousands) as min_sales,
       MAX(sales_thousands) as max_sales
   FROM ice_cream_sales
   GROUP BY location, strftime('%B', date)
   HAVING AVG(sales_thousands) > 90 AND COUNT(*) >= 5
   ORDER BY avg_sales DESC;
   ```

---

## Lab 4: Customer Behavior Analysis Project

### Objective

Apply advanced SQL techniques to analyze customer transaction patterns, employee performance impact, and build comprehensive business intelligence queries combining all three datasets.

### Steps

1. **Customer Demographics and Behavior Patterns**:
   ```sql
   -- Customer behavior by demographics and location
   SELECT 
       location,
       customer_age_group,
       COUNT(*) as transaction_count,
       AVG(total_spent) as avg_transaction,
       AVG(items_purchased) as avg_items,
       AVG(satisfaction_rating) as avg_satisfaction,
       COUNT(CASE WHEN return_customer = 'Yes' THEN 1 END) as returning_customers,
       ROUND(100.0 * COUNT(CASE WHEN return_customer = 'Yes' THEN 1 END) / COUNT(*), 1) as return_rate_pct
   FROM customer_transactions
   GROUP BY location, customer_age_group
   ORDER BY location, avg_transaction DESC;
   ```

2. **Employee Impact on Customer Satisfaction**:
   ```sql
   -- Join all three tables to analyze employee performance impact
   SELECT 
       e.first_name || ' ' || e.last_name as employee_name,
       e.position,
       e.location,
       COUNT(ct.id) as customers_served,
       AVG(ct.satisfaction_rating) as avg_satisfaction,
       AVG(ct.total_spent) as avg_transaction_value,
       SUM(ct.total_spent) as total_revenue_generated,
       e.performance_rating
   FROM employees e
   LEFT JOIN customer_transactions ct ON e.employee_id = ct.employee_id
   GROUP BY e.employee_id, e.first_name, e.last_name, e.position, e.location, e.performance_rating
   HAVING COUNT(ct.id) > 0
   ORDER BY avg_satisfaction DESC, total_revenue_generated DESC;
   ```

3. **Weather-Sensitive Customer Analysis**:
   ```sql
   -- Analyze weather-sensitive customers vs daily sales
   SELECT 
       s.date,
       s.location,
       s.temperature_f,
       s.is_rainy,
       s.sales_thousands as daily_sales,
       COUNT(ct.id) as total_transactions,
       COUNT(CASE WHEN ct.weather_sensitive = 'Yes' THEN 1 END) as weather_sensitive_customers,
       AVG(CASE WHEN ct.weather_sensitive = 'Yes' THEN ct.total_spent END) as avg_weather_sensitive_spend,
       AVG(CASE WHEN ct.weather_sensitive = 'No' THEN ct.total_spent END) as avg_regular_spend
   FROM ice_cream_sales s
   LEFT JOIN customer_transactions ct ON s.date = ct.date AND s.location = ct.location
   GROUP BY s.date, s.location, s.temperature_f, s.is_rainy, s.sales_thousands
   HAVING total_transactions > 0
   ORDER BY s.date, s.location;
   ```

4. **Time-Based Customer Patterns**:
   ```sql
   -- Analyze customer patterns by time of day
   SELECT 
       CASE 
           WHEN strftime('%H', transaction_time) BETWEEN '09' AND '11' THEN 'Morning (9-11 AM)'
           WHEN strftime('%H', transaction_time) BETWEEN '12' AND '14' THEN 'Lunch (12-2 PM)'
           WHEN strftime('%H', transaction_time) BETWEEN '15' AND '17' THEN 'Afternoon (3-5 PM)'
           ELSE 'Other'
       END as time_period,
       location,
       COUNT(*) as transaction_count,
       AVG(total_spent) as avg_spend,
       AVG(satisfaction_rating) as avg_satisfaction,
       COUNT(CASE WHEN promotional_code_used != 'NONE' THEN 1 END) as promo_usage
   FROM customer_transactions
   GROUP BY 
       CASE 
           WHEN strftime('%H', transaction_time) BETWEEN '09' AND '11' THEN 'Morning (9-11 AM)'
           WHEN strftime('%H', transaction_time) BETWEEN '12' AND '14' THEN 'Lunch (12-2 PM)'
           WHEN strftime('%H', transaction_time) BETWEEN '15' AND '17' THEN 'Afternoon (3-5 PM)'
           ELSE 'Other'
       END,
       location
   ORDER BY location, avg_spend DESC;
   ```

5. **Promotional Code Effectiveness**:
   ```sql
   -- Analyze promotional code impact on spending and satisfaction
   SELECT 
       promotional_code_used,
       COUNT(*) as usage_count,
       AVG(total_spent) as avg_spend,
       AVG(items_purchased) as avg_items,
       AVG(satisfaction_rating) as avg_satisfaction,
       COUNT(CASE WHEN return_customer = 'Yes' THEN 1 END) as returning_customers
   FROM customer_transactions
   GROUP BY promotional_code_used
   ORDER BY avg_spend DESC;
   ```

6. **Advanced Window Functions - Employee Performance Ranking**:
   ```sql
   -- Rank employees by revenue generation with moving averages
   SELECT 
       e.employee_id,
       e.first_name || ' ' || e.last_name as employee_name,
       e.location,
       e.position,
       COUNT(ct.id) as customers_served,
       SUM(ct.total_spent) as total_revenue,
       AVG(ct.satisfaction_rating) as avg_satisfaction,
       RANK() OVER (PARTITION BY e.location ORDER BY SUM(ct.total_spent) DESC) as revenue_rank_in_location,
       RANK() OVER (ORDER BY AVG(ct.satisfaction_rating) DESC) as satisfaction_rank_overall,
       LAG(SUM(ct.total_spent)) OVER (PARTITION BY e.location ORDER BY SUM(ct.total_spent) DESC) as prev_employee_revenue
   FROM employees e
   LEFT JOIN customer_transactions ct ON e.employee_id = ct.employee_id
   GROUP BY e.employee_id, e.first_name, e.last_name, e.location, e.position
   HAVING customers_served > 0
   ORDER BY e.location, revenue_rank_in_location;
   ```

7. **Create Business Intelligence Views**:
   ```sql
   -- Create a comprehensive business summary view
   CREATE VIEW business_summary AS
   SELECT 
       s.date,
       s.location,
       s.temperature_f,
       s.is_rainy,
       s.sales_thousands as daily_sales_k,
       COUNT(DISTINCT e.employee_id) as employees_working,
       COUNT(ct.id) as total_transactions,
       AVG(ct.total_spent) as avg_transaction_value,
       AVG(ct.satisfaction_rating) as avg_satisfaction,
       COUNT(CASE WHEN return_customer = 'Yes' THEN 1 END) as returning_customers,
       COUNT(CASE WHEN weather_sensitive = 'Yes' THEN 1 END) as weather_sensitive_customers
   FROM ice_cream_sales s
   LEFT JOIN employees e ON s.location = e.location
   LEFT JOIN customer_transactions ct ON s.date = ct.date AND s.location = ct.location
   GROUP BY s.date, s.location, s.temperature_f, s.is_rainy, s.sales_thousands;
   
   -- Use the view for quick analysis
   SELECT 
       location,
       AVG(daily_sales_k) as avg_daily_sales,
       AVG(avg_transaction_value) as avg_transaction,
       AVG(avg_satisfaction) as avg_satisfaction,
       SUM(returning_customers) as total_returning_customers
   FROM business_summary
   GROUP BY location
   ORDER BY avg_daily_sales DESC;
   ```

---

## Bonus Challenge: Executive Reporting Queries

### Create SQL queries that answer key business questions:

1. **Question**: Which employees generate the highest customer satisfaction and revenue per hour worked?
   ```sql
   -- Your solution here: Combine employee hours, customer transactions, and satisfaction ratings
   ```

2. **Question**: How does weather affect customer behavior differently across age groups and locations?
   ```sql
   -- Your solution here: Join weather data with customer transactions and analyze patterns
   ```

3. **Question**: What's the relationship between employee performance ratings and actual business metrics?
   ```sql
   -- Your solution here: Compare HR performance ratings with sales, satisfaction, and revenue data
   ```

4. **Question**: Identify the optimal staffing levels for each location based on sales and customer satisfaction.
   ```sql
   -- Your solution here: Analyze employee count vs sales performance and satisfaction ratings
   ```

5. **Question**: Which promotional codes are most effective for different customer segments and weather conditions?
   ```sql
   -- Your solution here: Analyze promo code usage, effectiveness, and environmental factors
   ```

---

## Next Module Preview

In **Module 3**, we will transition to Python and recreate these analyses using Pandas, while also learning data cleaning techniques and creating visualizations for the same dataset.
